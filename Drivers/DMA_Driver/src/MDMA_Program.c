/*
 * MDMA_Program.c
 *
 *  Created on: Sep 17, 2023
 *      Author: Hesham Yasser
 */




#include "../include/LIB/BIT_MATH.h"
#include "../include/LIB/STD_Types.h"
#include "../include/DMA/MDMA_Interface.h"
#include "../include/DMA/MDMA_private.h"
#include "../include/DMA/MDMA_Configurations.h"

static PtrToFunc_void DMA_CallBack[DMA_NUMBER][STREAM_NUMBER];

void MDMA_voidInit(void)
{
/********************DMA1 Initialization********************/
	/*Set Memory Burst Mode*/
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_MBURST);
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR |= (MDMA1_MEMORY_BURST_MODE << CR_MBURST);
	/*Set Peripheral Burst Mode*/
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_PBURST);
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR |= (MDMA1_PERIPHERAL_BURST_MODE << CR_PBURST);
	/*Set Double Buffer Mode*/
#if MDMA1_DOUBLE_BUFFER_MODE == MDMA_DOUBLE_BUFFER_ON
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_DBM);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_DBM);
#endif
	/*Set Priority level*/
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_PL);
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR |= (MDMA1_PRIORITY << CR_PL);
	/*Set Peripheral Increment Size*/
#if MDMA1_PERIPHERAL_INCREMENT_SIZE == MDMA_SIZE_FIXED_4BYTE
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_PINCOS);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_PINCOS);
#endif
	/*Set Memory increment Mode*/
#if MDMA1_MEMORY_INCREMENT_MODE == MDMA_POINTER_INCREMENTED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_MINC);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_MINC);
#endif
	/*Set Peripheral increment Mode*/
#if MDMA1_PERIPHERAL_INCREMENT_MODE == MDMA_POINTER_INCREMENTED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_PINC);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_PINC);
#endif
	/*Set Circular Mode*/
#if MDMA1_CIRCULAR_MODE == MDMA_CIRCULAR_MODE_ENABLED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_CIRC);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_CIRC);
#endif
	/*Set Data Transfer Direction*/
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_DIR);
	DMA1->S[MDMA1_STREAM_CONFIGURED].CR |= (MDMA1_DATA_TRANSFER_DIRECTION << CR_DIR);
	/*Set Peripheral flow controller*/
#if MDMA1_PERIPHERAL_FLOW_CONTROLLER == MDMA_PERIPHERAL_CONTROLLER
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_PFCTRL);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_PFCTRL);
#endif
	/*Set Several Interrupt States*/
#if MDMA1_TRANSFER_COMPLETE_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_TCIE);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_TCIE);
#endif
#if MDMA1_HALF_TRANSFER_COMPLETE_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_HTIE);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_HTIE);
#endif
#if MDMA1_TRANSFER_ERROR_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_TEIE);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_TEIE);
#endif
#if MDMA1_DIRECT_MODE_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_DMEIE);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].CR , CR_DMEIE);
#endif
#if MDMA1_FIFO_ERROR_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].FCR , FCR_FEIE);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].FCR , FCR_FEIE);
#endif
	/*Set Direct Mode*/
#if MDMA1_DIRECT_MODE == MDMA_DIRECT_MODE_DISABLED
	SET_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].FCR , FCR_DMDIS);
#else
	CLR_BIT (DMA1->S[MDMA1_STREAM_CONFIGURED].FCR , FCR_DMDIS);
#endif
	/*Set FIFO Threshold*/
	DMA1->S[MDMA1_STREAM_CONFIGURED].FCR &= ~(TWO_BIT_MASK << FCR_FTH);
	DMA1->S[MDMA1_STREAM_CONFIGURED].FCR |= (MDMA1_FIFO_THRESHOLD << FCR_FTH);


/********************DMA2 Initialization********************/
	CLR_BIT(DMA2->S[MDMA2_STREAM_CONFIGURED].CR , MDMA_ENABLE);
	/*Set Memory Burst Mode*/
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_MBURST);
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR |= (MDMA2_MEMORY_BURST_MODE << CR_MBURST);
	/*Set Peripheral Burst Mode*/
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_PBURST);
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR |= (MDMA2_PERIPHERAL_BURST_MODE << CR_PBURST);
	/*Set Double Buffer Mode*/
#if MDMA2_DOUBLE_BUFFER_MODE == MDMA_DOUBLE_BUFFER_ON
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_DBM);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_DBM);
#endif
	/*Set Priority level*/
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_PL);
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR |= (MDMA2_PRIORITY << CR_PL);
	/*Set Peripheral Increment Size*/
#if MDMA2_PERIPHERAL_INCREMENT_SIZE == MDMA_SIZE_FIXED_4BYTE
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_PINCOS);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_PINCOS);
#endif
	/*Set Memory increment Mode*/
#if MDMA2_MEMORY_INCREMENT_MODE == MDMA_POINTER_INCREMENTED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_MINC);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_MINC);
#endif
	/*Set Peripheral increment Mode*/
#if MDMA2_PERIPHERAL_INCREMENT_MODE == MDMA_POINTER_INCREMENTED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_PINC);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_PINC);
#endif
	/*Set Circular Mode*/
#if MDMA2_CIRCULAR_MODE == MDMA_CIRCULAR_MODE_ENABLED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_CIRC);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_CIRC);
#endif
	/*Set Data Transfer Direction*/
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR &= ~(TWO_BIT_MASK << CR_DIR);
	DMA2->S[MDMA2_STREAM_CONFIGURED].CR |= (MDMA2_DATA_TRANSFER_DIRECTION << CR_DIR);
	/*Set Peripheral flow controller*/
#if MDMA2_PERIPHERAL_FLOW_CONTROLLER == MDMA_PERIPHERAL_CONTROLLER
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_PFCTRL);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_PFCTRL);
#endif
	/*Set Several Interrupt States*/
#if MDMA2_TRANSFER_COMPLETE_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_TCIE);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_TCIE);
#endif
#if MDMA2_HALF_TRANSFER_COMPLETE_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_HTIE);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_HTIE);
#endif
#if MDMA2_TRANSFER_ERROR_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_TEIE);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_TEIE);
#endif
#if MDMA2_DIRECT_MODE_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_DMEIE);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].CR , CR_DMEIE);
#endif
#if MDMA2_FIFO_ERROR_INTERRUPT_STATE == MDMA_INTERRUPT_ENABLED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].FCR , FCR_FEIE);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].FCR , FCR_FEIE);
#endif
	/*Set Direct Mode*/
#if MDMA2_DIRECT_MODE == MDMA_DIRECT_MODE_DISABLED
	SET_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].FCR , FCR_DMDIS);
#else
	CLR_BIT (DMA2->S[MDMA2_STREAM_CONFIGURED].FCR , FCR_DMDIS);
#endif
	/*Set FIFO Threshold*/
	DMA2->S[MDMA2_STREAM_CONFIGURED].FCR &= ~(TWO_BIT_MASK << FCR_FTH);
	DMA2->S[MDMA2_STREAM_CONFIGURED].FCR |= (MDMA2_FIFO_THRESHOLD << FCR_FTH);

}

void MDMA_voidSetStreamConfigurations(u8   A_u8DMAID,
								 u8	  A_u8StreamID,
								 u8   A_u8ChannelID,
								 u32* p_u8SourceAddress,
								 u32* p_u8DestinationAddress,
								 u8	  A_u8DataSize,
								 u16  A_u16BlockSize)
{
	if (A_u8DMAID < DMA_NUMBER && A_u8StreamID <STREAM_NUMBER && A_u8ChannelID < CHANNEL_NUMBER)
	{
		switch (A_u8DMAID)
		{
		case MDMA1:
			/*Select Channel*/
			DMA1->S[A_u8StreamID].CR &= ~(THREE_BIT_MASK << CR_CHSEL);
			DMA1->S[A_u8StreamID].CR |= (A_u8ChannelID << CR_CHSEL);
			/*Set Data Size*/
			DMA1->S[A_u8StreamID].CR &= ~(TWO_BIT_MASK << CR_MSIZE);
			DMA1->S[A_u8StreamID].CR |= (A_u8DataSize << CR_MSIZE);
			DMA1->S[A_u8StreamID].CR &= ~(TWO_BIT_MASK << CR_PSIZE);
			DMA1->S[A_u8StreamID].CR |= (A_u8DataSize << CR_PSIZE);
			/*Set Block Size*/
			DMA1->S[A_u8StreamID].NDTR = A_u16BlockSize;
			/*Set Source and Destination Addresses*/
#if MDMA1_DATA_TRANSFER_DIRECTION == MDMA_PERIPHERAL_TO_MEMORY
			DMA1->S[A_u8StreamID].M0AR = (u32)p_u8DestinationAddress;
			DMA1->S[A_u8StreamID].PAR = (u32)p_u8SourceAddress;
#elif MDMA1_DATA_TRANSFER_DIRECTION == MDMA_MEMORY_TO_PERIPHERAL
			DMA1->S[A_u8StreamID].M0AR = (u32)p_u8SourceAddress;
			DMA1->S[A_u8StreamID].PAR = (u32)p_u8DestinationAddress;
#elif MDMA1_DATA_TRANSFER_DIRECTION == MDMA_MEMORY_TO_MEMORY
			DMA1->S[A_u8StreamID].M0AR = (u32)p_u8DestinationAddress;
			DMA1->S[A_u8StreamID].PAR = (u32)p_u8SourceAddress;
#else
#error WRONG_DMA1_DATA_DIRECTION
#endif
			break;
		case MDMA2:
			/*Select Channel*/
			DMA2->S[A_u8StreamID].CR &= ~(THREE_BIT_MASK << CR_CHSEL);
			DMA2->S[A_u8StreamID].CR |= (A_u8ChannelID << CR_CHSEL);
			/*Set Data Size*/
			DMA2->S[A_u8StreamID].CR &= ~(TWO_BIT_MASK << CR_MSIZE);
			DMA2->S[A_u8StreamID].CR |= (A_u8DataSize << CR_MSIZE);
			DMA2->S[A_u8StreamID].CR &= ~(TWO_BIT_MASK << CR_PSIZE);
			DMA2->S[A_u8StreamID].CR |= (A_u8DataSize << CR_PSIZE);
			/*Set Block Size*/
			DMA2->S[A_u8StreamID].NDTR = A_u16BlockSize;
			/*Set Source and Destination Addresses*/
#if MDMA2_DATA_TRANSFER_DIRECTION == MDMA_PERIPHERAL_TO_MEMORY
			DMA2->S[A_u8StreamID].M0AR = (u32)p_u8DestinationAddress;
			DMA2->S[A_u8StreamID].PAR = (u32)p_u8SourceAddress;
#elif MDMA2_DATA_TRANSFER_DIRECTION == MDMA_MEMORY_TO_PERIPHERAL
			DMA2->S[A_u8StreamID].M0AR = (u32)p_u8SourceAddress;
			DMA2->S[A_u8StreamID].PAR = (u32)p_u8DestinationAddress;
#elif MDMA2_DATA_TRANSFER_DIRECTION == MDMA_MEMORY_TO_MEMORY
			DMA2->S[A_u8StreamID].M0AR = (u32)p_u8DestinationAddress;
			DMA2->S[A_u8StreamID].PAR = (u32)p_u8SourceAddress;
#else
#error WRONG_DMA2_DATA_DIRECTION
#endif
			break;
		}
	}

}

void MDMA_voidSetCallBack(u8 A_u8DMAID , u8 A_u8StreamID ,PtrToFunc_void A_CallBack)
{
	if (A_u8DMAID < DMA_NUMBER && A_u8StreamID <STREAM_NUMBER && A_CallBack != NULL)
	{
		DMA_CallBack[A_u8DMAID][A_u8StreamID] = A_CallBack;
	}
}

void MDMA_voidEnableStream (u8 A_u8DMAID , u8 A_u8StreamID)
{
	if (A_u8DMAID < DMA_NUMBER && A_u8StreamID <STREAM_NUMBER)
	{
		switch (A_u8DMAID)
		{
		case MDMA1:
			SET_BIT((DMA1->S[A_u8StreamID].CR) , MDMA_ENABLE);
			break;
		case MDMA2:
			SET_BIT((DMA2->S[A_u8StreamID].CR) , MDMA_ENABLE);
			break;
		}
	}
}


void DMA2_Stream0_IRQHandler (void)
{
	if (DMA_CallBack[MDMA2][MDMA_STREAM0] != NULL)
	{
		DMA_CallBack[MDMA2][MDMA_STREAM0]();
	}
	SET_BIT (DMA2->LIFCR , LIFCR_CTCIF0);
}
